// let mut x = 22;
// let mut v = vec![];
// let p = &x;
// let mut tmp = &mut v;
// Vec::push(tmp, p);
// x = 23;
// Vec::len(v); // ERROR

// Decls
// let x: u32
// let v: Vec<&'v mut u32>
// let p: &'p u32
// let tmp: &'tmp0 mut Vec<&'tmp1 mut u32>
//
// Loans
// L_x

a: "x = 22" {
    invalidate_loan(L_x)
    goto b
}

b: "v = vec![]" {
    invalidate_loan(L_v)
    goto c
}

c: "p = &'0 x" {
    // Clear all origins in `p` (overwritten plan):
    clear_origin('p)

    // From the borrow of `x`
    introduce_loan(L_x, '0)

    // `&'0 u32 <: &'p u32`
    introduce_subset('0, 'p) 
    goto d
}

d: "tmp = &'1 mut v" {
    introduce_loan(L_v, '1)

    // &'1 mut Vec<&'v mut u32> <: &'tmp0 Vec<&'tmp1 mut u32>
    introduce_subset('1, 'tmp0)
    introduce_subset('tmp1, 'v)
    introduce_subset('v, 'tmp1)
    goto e
}

e: "Vec::push(tmp, p)" {
    // Access origins in the arguments
    access('tmp0)
    access('tmp1)
    access('p)

    // Signature requires `&'p u32` <: `&'tmp1 u32`:
    introduce_subset('p, 'tmp1)
    goto f

}

f: "x = 23" {
    invalidate_loan(L_x)
    goto g
}

g: "Vec::len(v)" {
    access('v)
    goto
}