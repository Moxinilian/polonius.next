.type Origin <: symbol
.type Node <: symbol

/////////////////////////////////////////////


// access_origin data with origin `o` at node `n`
.decl access_origin(o: Origin, n: Node)
.input access_origin

// Invalidate the origin `o` at the node `n`
.decl invalidate_origin(o: Origin, n: Node)
.input invalidate_origin

// All references with origin `o` are overwritten at node `n`
.decl clear_origin(o: Origin, n: Node)
.input clear_origin

// Require that `o1 <= o2` at node `n`
.decl introduce_subset(o1: Origin, o2: Origin, n: Node)
.input introduce_subset

// Control-flow graph edge `n1 -> n2`
.decl cfg_edge(n1: Node, n2: Node)
.input cfg_edge

/////////////////////////////////////////////
.decl subset(o1: Origin, o2: Origin, n: Node)
.output subset

subset(O1, O2, N2) :- // Introduced by predecessor
  cfg_edge(N1, N2),
  introduce_subset(O1, O2, N1).

subset(O1, O2, N2) :- // Carried over from predecessor
  cfg_edge(N1, N2),
  subset(O1, O2, N1),
  !clear_origin(O1, N1),
  !clear_origin(O2, N1).

subset(O1, O3, N1) :- // Transitive closure
  subset(O1, O2, N1),
  subset(O2, O3, N1).

////////////////////////////////////////////
.decl origin_invalidated(o: Origin, n: Node)
.output origin_invalidated

origin_invalidated(O2, N2) :- // Introduced by predecessor
  cfg_edge(N1, N2),
  !clear_origin(O2, N1),
  subset(O1, O2, N1),
  invalidate_origin(L, O1).

origin_invalidated(O, N2) :- // Introduced by predecessor
  cfg_edge(N1, N2),
  !clear_origin(O, N1),
  invalidate_origin(L, O, N1).

/////////////////////////////////////////////////////
.decl invalidated_origin_accessed(o: Origin, n: Node)
.output invalidated_origin_accessed

invalidated_origin_accessed(O, N) :- // Introduced by predecessor
  access_origin(O, N),
  origin_invalidated(O, N).

